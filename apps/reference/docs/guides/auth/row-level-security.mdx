---
id: row-level-security
title: Row Level Security
description: Secure your data using Postgres Row Level Security.
---

When you need granular authorization rules, nothing beats PostgreSQL's [Row
Level Security
(RLS)](https://www.postgresql.org/docs/current/ddl-rowsecurity.html).

[Policies](https://www.postgresql.org/docs/current/sql-createpolicy.html) are
PostgreSQL's rule engine. They are incredibly powerful and flexible, allowing
you to write complex SQL rules which fit your unique business needs.

<div class="video-container">
  <iframe
    src="https://www.youtube-nocookie.com/embed/Ow_Uzedfohk"
    frameBorder="1"
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
    allowFullScreen
  ></iframe>
</div>

## Policies

Policies are easy to understand once you get the hang of them. Each policy is
attached to a table, and the policy is executed every time a table is accessed.
You can just think of them as adding a `WHERE` clause to every query. For
example a policy like this:

```sql
create policy "Individuals can view their own todos."
  on todos
  as restrictive
  for select
  using ( auth.uid() = user_id );
```

Would translate to this whenever a user tries to select from the todos
table:

```sql
select *
  from todos
  where auth.uid() = todos.user_id; -- Policy is implicitly added.
```

### Restrictive vs. Permissive

Many policies can be attached to a table, allowing you to simplify the
management of complex authorization rules.

PostgreSQL supports two modes for composing policies.

1. **Permissive.**  
Only one policy needs to evaluate to `true` and the command will be executed.
2. **Restrictive.**  
All policies must evaluate to `true` for the command to be executed.

**Unless you explicitly specify that policies are restrictive, they are
permissive by default. This may produce some surprising results!**

You can declare a policy as **restrictive** by adding `as restrictive`
to the `create policy` statement. Example:

```sql
create policy "Policy name."
  on table_name
  as restrictive -- <<< important bit
  ...
  using ...;
```

If you have both permissive and restrictive policies defined for a table, the
rule is that **all of the restrictive must evaluate to `true` and only one of
the permissive ones.**

:::tip
We recommend you always declare policies `as restrictive` because this often
reduces accidental broadening of access.
:::

A fairly common problem occurs when adding a policy such as:

```sql
create policy "Allow everyone to read table."
  on table_name
  for select
  using (true);
```

_Note the missing `as restricted` clause._

This policy naively says that everyone will be given read access to the table.
This is true until you attempt to add a more restrictive policy in the future
without removing the previous one. For example, you may want to add another
policy on the same table that checks whether the `is_public` column is `true`:

```sql
create policy "Allow only public rows to be read by everyone."
  on table_name
  for select
  using (is_public = true);
```

_Note the missing `as restricted` clause, again._

The desired effect of the second policy would in fact not apply, since the
first policy lets everyone read all rows. According to the PostgreSQL rules for
permissive policies, only one needs to evaluate to `true`. Thus any policy you
may add without an `as restrictive` clause will never apply.

#### Tips

You can avoid this undesirable scenario by consistently following these rules:

1. Always use `as restricted` in policy statements.
2. Keep policies short and easy to read. You can use full strings for policy
names.
3. If you must use permissive policies, avoid the use of statements such as
`using (true)` that give broad access.
4. Periodically review all policies as a whole to catch subtle issues.

## Examples

Here are some examples to show you the power of PostgreSQL's RLS.

### Allow read access

```sql
-- 1. Create table
create table profiles (
  id uuid references auth.users,
  avatar_url text
);

-- 2. Enable RLS
alter table profiles
  enable row level security;

-- 3. Create Policy
create policy "Public profiles are viewable by everyone."
  on profiles
  as restrictive -- very important when using (true)
  for select using (true);
```

:::warning
Always mark policies `as restrictive` if the `using` clause is `true` as shown
in the example above. Otherwise, all rows will be visible once the restricted
policies match!
:::

1. Creates a table called `profiles` in the public schema (default schema).
2. Enables Row Level Security.
3. Creates a policy which allows all `select` queries to run.

### Restrict updates

```sql
-- 1. Create table
create table profiles (
  id uuid references auth.users,
  avatar_url text
);

-- 2. Enable RLS
alter table profiles
  enable row level security;

-- 3. Create Policy
create policy "Users can update their own profiles."
  on profiles
  as restrictive
  for update using (
    auth.uid() = id
  );
```

1. Creates a table called `profiles` in the public schema (default schema).
2. Enables RLS.
3. Creates a policy which allows logged in users to update their own data.

### Only `anon` or `authenticated` access

You can add a Postgres role

```sql
create policy "Public profiles are viewable by everyone."
  on profiles
  as restrictive -- very important when using (true)
  for select
  to authenticated, anon
  using (true);
```

:::warning
Always mark policies `as restrictive` if the `using` clause is `true` as shown
in the example above. Otherwise, all rows will be visible once the restricted
policies match!
:::

### Policies with joins

Policies can even include table joins. This example shows how you can query
"external" tables to build more advanced rules.

```sql
create table teams (
  id serial primary key,
  name text
);

-- 2. Create many to many join
create table members (
  team_id bigint references teams,
  user_id uuid references auth.users
);

-- 3. Enable RLS
alter table teams
  enable row level security;

-- 4. Create Policy
create policy "Team members can update team details if they belong to the team."
  on teams
  as restricitve
  for update using (
    auth.uid() in (
      select user_id from members
      where team_id = id
    )
  );
```

**Note:** If RLS is also enabled for _members_, the user must also have read
(_select_) access to _members_. Otherwise the joined query will not yield any
results.

### Policies with security definer functions

Policies can also make use of `security definer functions`. This is useful in a
many-to-many relationship where you want to restrict access to the linking
table. Following the `teams` and `members` example from above, this example
shows how you can use the security definer function in combination with a
policy to control access to the `members` table.

```sql
-- 1. Follow example for 'Policies with joins' above

-- 2.  Enable RLS
alter table members
  enable row level security

-- 3.  Create security definer function
create or replace function get_teams_for_authenticated_user()
returns setof bigint
language sql
security definer
set search_path = public
stable
as $$
    select team_id
    from members
    where user_id = auth.uid()
$$;

-- 4. Create Policy
create policy "Team members can update team members if they belong to the team."
  on members
  as restrictive
  for all using (
    team_id in (
      select get_teams_for_authenticated_user()
    )
  );

```

### Verifying email domains

Postgres has a function `right(string, n)` that returns the rightmost n
characters of a string. You could use this to match staff member's email
domains.

```sql
-- 1. Create table
create table leaderboard (
  id uuid references auth.users,
  high_score bigint
);

-- 2. Enable RLS
alter table leaderboard
  enable row level security;

-- 3. Create Policy
create policy "Only Blizzard staff can update leaderboard"
  on leaderboard
  as restrictive
  for update using (
    right(auth.jwt() ->> 'email', 13) = '@blizzard.com'
  );
```

### Time to live for rows

Policies can also be used to implement TTL or time to live feature that you see
in Instagram stories or Snapchat.  In the following example, rows of `stories`
table are available only if they have been created within the last 24 hours.

```sql
-- 1. Create table
create table if not exists stories (
  id uuid not null primary key DEFAULT uuid_generate_v4(),
  created_at timestamp with time zone default timezone('utc' :: text, now()) not null,
  content text not null
);

-- 2. Enable RLS
alter table stories
  enable row level security;

-- 3. Create Policy
create policy "Stories are live for a day"
  on stories
  as restrictive
  for select using (
    created_at > (current_timestamp - interval '1 day')
  );
```

### Advanced policies

Use the full power of SQL to build extremely advanced rules.

In this example, we will create a `posts` and `comments` tables and then create
a policy that depends on another policy.  (In this case, the comments policy
depends on the posts policy.)

```sql
create table posts (
  id            serial    primary key,
  creator_id    uuid      not null     references auth.users(id),
  title         text      not null,
  body          text      not null,
  publish_date  date      not null     default now(),
  audience      uuid[]    null -- many to many table omitted for brevity
);

create table comments (
  id            serial    primary key,
  post_id       int       not null     references posts(id)  on delete cascade,
  user_id       uuid      not null     references auth.users(id),
  body          text      not null,
  comment_date  date      not null     default now()
);

create policy "Creator can see their own posts"
  on posts
  as restrictive
  for select
  using (
    auth.uid() = posts.creator_id
  );

create policy "Logged in users can see the posts if they belong to the post 'audience'."
  on posts
  as restrictive
  for select
  using (
    auth.uid() = any (posts.audience)
  );

create policy "Users can see all comments for posts they have access to."
  on comments
  as restrictive
  for select
  using (
    exists (
      select 1 from posts
      where posts.id = comments.post_id
    )
  );
```

## Tips

### Enable Realtime for database tables

Realtime server broadcasts database changes to authorized users depending on
your Row Level Security (RLS) policies. We recommend that you enable row level
security and set row security policies on tables that you add to the
publication. However, you may choose to disable RLS on a table and have
changes broadcast to all connected clients.

```sql
/**
 * REALTIME SUBSCRIPTIONS
 * Realtime enables listening to any table in your public schema.
 */

begin;
  -- remove the realtime publication
  drop publication if exists supabase_realtime;

  -- re-create the publication but don't enable it for any tables
  create publication supabase_realtime;
commit;

-- add a table to the publication
alter publication supabase_realtime add table products;

-- add other tables to the publication
alter publication supabase_realtime add table posts;
```

### You don't have to use policies

You can also put your authorization rules in your middleware, similar to how
you would create security rules with any other `backend <-> middleware <->
frontend` architecture.

Policies are a tool. In the case of "serverless/Jamstack" setups, they are
especially effective because you don't have to deploy any middleware at all.

However, if you want to use another authorization method for your applications,
that's also fine. Supabase is "just Postgres", so if your application works
with Postgres, then it also works with Supabase.

Tip: Make sure to enable RLS for all your tables, so that your tables are
inaccessible. Then use the "Service" which we provide, which is designed to
bypass RLS.

### Never use a service key on the client

Supabase provides special "Service" keys, which can be used to bypass all RLS.
These should never be used in the browser or exposed to customers, but they are
useful for administrative tasks.

## Built-in authentication functions

Supabase provides you with a few easy functions that you can use with your policies.

### `auth.uid()`

Returns the ID of the user making the request.

### `auth.jwt()`

Returns the JWT of the user making the request. The returned value is a
[PostgreSQL JSON
object](https://www.postgresql.org/docs/current/functions-json.html) of the JWT
body.

Some useful operators:

- `X->>Y`  
Access the property `Y` (can be an index for arrays, or a key for objects) on
the object `X` as if the value was text (string). If `X` is not a JSON object
or `Y` is not defined, it returns `NULL`.
- `X#>>array[A,B,C]`  
Access the value nested by accessing `A` then `B` and then `C`, as if the final
value was text (string). If the path does not exist, it returns `NULL`.

### `auth.role()`

:::caution
Deprecated. Use the built-in `to role, ...` SQL clause when creating a policy.

```sql
create or replace policy "Policy name."
  on table_name
  to authenticated, anon -- <<< roles that the policy applies to
  ...
  using ...;
```
:::

```sql
-- DEPRECATED
create policy "Public profiles are viewable by everyone."
  on profiles
  as restrictive
  for select using (
    auth.role() = 'authenticated' or auth.role() = 'anon'
  );

-- RECOMMENDED
create policy "Public profiles are viewable by everyone."
  on profiles
  as restrictive -- very important when using (true)
  for select
  to authenticated, anon
  using (true);
```

:::warning
Always mark policies `as restrictive` if the `using` clause is `true` as shown
in the example above. Otherwise, all rows will be visible once the restricted
policies match!
:::

### `auth.email()`

:::caution

Deprecated. Use `auth.jwt() ->> 'email'` instead.

:::

Returns the email of the user making the request.
